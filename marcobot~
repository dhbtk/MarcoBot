#!/usr/bin/env ruby
# MarcoBot: THE REWRITE; Version 2.0
# Firstly, the basics. Commands will come later. <-- are already coming (TWSS)
# Already supports:
# fucktons of things
#require 'rubygems'
require "socket"
require "yaml"
require "net/http"
require "rexml/document"
require "./faidio.rb"
require "./wiki.rb"
require "./macros.rb"
#require "hpricot"
class IRCBot
	include Faidio
	include Wiki
	include Macros
	# initialize: get these nasty vars and make them globals.
	def initialize(server,port,nick,autojoin_channels,ns_password,basepath)
		@server = server
		@port = port
		@nick = nick
		@channel = autojoin_channels.downcase.split(",")
		puts @channel
		@ns_password = ns_password
		@basepath = "/home/marcobot/"
		@command_identifier = "~"
		@leavearray = Hash.new
		@logarray = Hash.new
		@voterarray = Hash.new
		@macros_enabled = true
		@macrofile = nil
		@timeout = Time.new
		@macrotime = Hash.new
		@macrofile = File.open("#{@basepath}macros","r")
		@yamlmacros = YAML::load(@macrofile)
		@macrofile.rewind
		@macros = @macrofile.readlines
		
#		@blocking = false
	end
	# sends stuff through the socket
	def send(message)
#		puts "[#{Time.new.hour}:#{Time.new.min}:#{Time.new.sec}] --> #{message}"
		@irc.send "#{message}\n",0
		rawlog("--> #{message}")
	end
	# Connects to IRC
	def connect()
		puts "Connecting..."
		@irc = TCPSocket.open(@server,@port)
		puts "Connected!"
		send("USER MarcoBot foo bar :NieXS' MacroBot, Version 2.0")
		send("NICK #{@nick}")
		@connected = true;
	end
	def disconnect()
		send("QUIT Farewell")
		@connected = false;
	end
	# Handles the input, passing it to the appropriate functions
	def handle_server_input(s)
		s = s.strip.chomp
		s_spaces = s.sub(":","").split
		s_colons = s.split(":")
		message = s_colons.join(":").sub(s_colons[1],"").sub("::","")
		if s_spaces[0] == "PING" then
			send "PONG "+s_spaces[1].sub(":","")
		elsif s_spaces[1] == "PRIVMSG" then
			user = s_spaces[0].sub(":","").split("!")[0]
			target = s_spaces[2]
			message = s_colons.join(":").sub(s_colons[1],"").sub("::","")
			handle_message(user,target,message)
		elsif s_spaces[1] == "INVITE" then
			handle_invite(s_spaces[3])
		elsif s_spaces[1] == "TOPIC" then
			handle_topic(s_spaces[0],s_spaces[2],s_colons.join(":").sub(s_colons[1],"").sub("::",""))
		elsif s_spaces[1] == "KICK" then
			handle_kick(s_spaces[0],s_spaces[2],s_spaces[3],s_spaces[4])
		elsif s == ":#{@nick} MODE #{@nick} :+wx" then
			startup_routine()
		elsif s_spaces[1] == "MODE" then
			if s_spaces[4] != nil then
				log(s_spaces[2],s_spaces[0],"#{s_spaces[3]} #{s_spaces[4]}","usermode")
			else
				log(s_spaces[2],s_spaces[0],s_spaces[3],"chanmode")
			end
		elsif s_spaces[1] == "PART" then
			log(s_spaces[2],s_spaces[0],message,"part")
			if s_spaces[0].split("!")[0] == @nick then
				@channel.delete(s_spaces[2].downcase)
			end
		elsif s_spaces[1] == "JOIN" then
			log(s_spaces[2],s_spaces[0],"","join")
			if s_spaces[0].split("!")[0] == @nick then
				@channel.push(s_spaces[2].sub(":","").downcase)
				privmsg(s_spaces[2].sub(":",""),"Hello #{s_spaces[2].sub(":","")} people!")
			end
		elsif s_spaces[1] == "QUIT" then
			for channel in @channel
				log(channel,s_spaces[2],message,"quit")
			end
		elsif s_spaces[1] == "NICK" then
			if s_spaces[0].split("!")[0] == @nick then
				newnick = s_spaces[2].sub(":","").strip
				@nick = newnick
			end
			for channel in @channel
				log(channel,s_spaces[0],newnick,"nick")
			end
			
		end
		if s_spaces[0] = ":"+@server then
			log("Network",@server,s.strip,"network")
		end
	end
	# Looping and looping and looping again...
	def main_loop()
		while true and @connected
			ready = select([@irc],nil,nil,nil)
			next if !ready
			for s in ready[0]
				return if @irc.eof
				s = @irc.gets
				rawlog(s)
				handle_server_input(s)		
			end			
		end
	end
	def rawlog(s)
#		puts "#{timestamp(Time.new)} #{s}" 
		@rawlogfile = File.open("/var/log/marcobot/rawlog","a+")
		@rawlogfile.puts("#{timestamp(Time.new)}> #{s}")
		@rawlogfile.close()
	end
	def timestamp(time) # Pretty timestamps!
		hour = (time.hour<10 ? "0"+time.hour.to_s : time.hour)
		minute = (time.min<10 ? "0"+time.min.to_s : time.min)
		second = (time.sec<10 ? "0"+time.min.to_s : time.sec)
		thetime = "[#{hour}:#{minute}:#{second}]"
		return thetime
	end
	def handle_message(user,target,message)
		if target[0..0] == "#" then
			# Stuff that is happening in a chan
			check_for_macro(message,target,user) if @macros_enabled
			check_for_command(message,target,user)
			if message.sub("ACTION ","") == message then
				log(target,user,message,"privmsg")
			else
				log(target,user,message,"emote")
				if message.start_with?("ACTION rolls ") then
					dieroll(target,message.sub("ACTION rolls ","").sub("",""))
				end
			end
		else
			# Stuff in a PM.
			check_for_command(message,user,user)
			check_for_admin_command(message,user)
			if message.sub("ACTION ","") == message then
				log(user,user,message,"privmsg")
			else
				log(user,user,message,"emote")
			end
		end
	end
	def handle_invite(channel)
		#TODO: call for logs
#		if invited == @nick then
			send("JOIN #{channel}")
			privmsg(channel,"Hello #{channel}!")
#		end
#		log(channel,user,invited,"invite")
	end
	def handle_topic(user,channel,newtopic)
		#TODO
		log(channel,user,newtopic,"topic")

	end
	def handle_kick(kicker,kicked,channel,cause)
		#TODO: Call for logging
		if kicked == @nick then
			send "JOIN #{channel}"
			emote(channel,"kicks #{kicker} in the face")
		end
		log(channel,kicker,"#{kicked}\n#{cause}","kick")
	end
	def startup_routine()
		
		send("MODE #{@nick} +TB")
		for channel in @channel
			send("JOIN #{channel}")
		end
		privmsg("NickServ","IDENTIFY #{@ns_password}")
	end
	# The needed: PRIVMSG
	def privmsg(target,message)
		send("PRIVMSG #{target} :#{message}")
		log(target,@nick,message,"privmsg")
	end
	# Because everyone loves /me
	def emote(target,message)
		privmsg(target,"ACTION #{message}")
		log(target,@nick,"ACTION #{message}","emote")
	end
	# Logging, because my mind said so
	def log(target,user,message,command)
		filepath = "/var/log/marcobot/logs/#{target.strip}-#{Time.new.day}-#{Time.new.month}-#{Time.new.year}".downcase
		if File.exists?(filepath) then
			@logarray[filepath] = File.open(filepath,"a")
		else
			@logarray[filepath] = File.new(filepath,"a")
		end
		begin
		case command
			when "privmsg"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} <#{user}> #{message.gsub("\n","")}"
			when "emote"
				time = Time.new
				message = message.sub("ACTION ","")
				message = message.gsub("","")
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} #{message.gsub("\n","")}"
			when "invite"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has invited #{message} into #{target}."
			when "topic"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has changed the topic to: #{message}"
			when "part"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user.split("!")[0]} (#{user}) has left #{target} (#{message})"
			when "join"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user.split("!")[0]} (#{user}) has joined #{target}"
			when "chanmode"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has changed the channel mode: #{message}"
			when "usermode"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has changed #{message.split(" ")[1]}'s mode: #{message.split(" ")[0]}"
			when "quit"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user.split("!")[0] unless user.class == NilClass} (#{user}) has left IRC: #{message}"
			when "kick"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has kicked #{message.split("\n")[0]} from #{target} (#{message.split("\n")[1]})"
			when "network"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} #{message}"
			when "nick"
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} is now known as #{message}."
				
		end
		rescue Exception => detail
			privmsg(target,"Oh dear, an exception: #{detail.message()}")
		end
		@logarray[filepath].close()
	end
	#
	#|------------------------------|
	#|HUMUNGUOUS COMMANDS LAY BEYOND|
	#|------------------------------|
	#
	# Checks for ADMIN commands in messages. Format: ADMIN password ~command params
	def check_for_admin_command(message,user)
		if message[0..4] == "ADMIN" then
			message_split = message.split # By spaces, the default
			command = message_split[2].sub(@command_identifier,"")
			password = message_split[1]
			# Params are slightly more complicated. We need to set message_split[0,1,2] to nil first, and then join the message via spaces, and then strip the first three spaces. IF there is a param.
			if message_split[3] != nil then
				message_split[0] = nil
				message_split[1] = nil
				message_split[2] = nil
				params = message_split.join(" ")
				params = params.sub("   ","")
			end
			# It is a command. Let's see...
			if password == "854600" then
				case command
					when "die"
						disconnect()
					when "raw"
						send(params)
					when "help"
						privmsg(user,"ADMIN commands: die, raw, help, join, part.")
					when "join"
						send("JOIN #{params}")
					when "part"
						@leavearray[params.gsub(" ","")] = 0
						send("PART #{params}")
					when "nick"
						send("NICK #{params.strip}")
				end
			else
				privmsg(user,"Wrong password.")
			end
		end
	end
	def check_for_command(message,target,user)
		if message[0..@command_identifier.length-1] == @command_identifier then #TODO: unhardcode this
			message_split = message.split
			command = message_split[0] if message_split[1] != nil
			command = message if message_split[1] == nil
			command = command.sub(@command_identifier,"")	
			command = command.sub(" ","")
			if message_split[1] != nil then
				message_split[0] == ""
				params = message_split.join(" ")
#				params = params.sub(" ","")
			end
			case command
				when "help"
					privmsg(user,"Commands:")
					privmsg(user,"~help     : Shows this help.")
					privmsg(user,"~coinflip : Flips a coin [citation needed] and shows the outcome.")
					privmsg(user,"~8ball    : Ask a question to the mighty 8-ball. \"Should I?\" questions are preferred.")
					privmsg(user,"~leave    : Adds a vote for me to leave. Six votes = leave channel.")
					privmsg(user,"~live     : Unvotes.")
					privmsg(user,"~thetime  : Prints the Brazilian time.")
					privmsg(user,"~shutup   : Toggles macros.")
					privmsg(user,"~macro    : Sets macros. They must have more than five characters. Setting them to a space removes them. Usage: ~macro input phrase=output phrase")
					privmsg(user,"~wiki     : Usage: ~wiki Article. Case-sensitive. Buggy as hell, use at your own risk.")
					privmsg(user,"~dieroll  : Usage: ~dieroll (dice)d(sides). Both must be natural numbers, and larger than two for the sides.")
					privmsg(user,"~echo     : echo echo cho cho o o")
					privmsg(user,"~linecount: Number of lines in the source code.")
					privmsg(user,"~faidio   : Shows FaiDio streams.")
				when "coinflip"
					i = rand(2)
					case i
						when 0
							privmsg(target,"Heads.")
						when 1
							privmsg(target,"Tails.")
					end
				when "8ball"
					i = rand(6)
					case i 
						when 0
							privmsg(target,"Of course.")
						when 1
							privmsg(target,"Mmm, perhaps.")
						when 2
							privmsg(target,"You shouldn't.")
						when 3
							privmsg(target,"Not really.")
						when 4
							privmsg(target,"Don't or you will suffer.")
						when 5
							privmsg(target,"You can't know for sure.")
					end
				when "leave"
					 if target[0..0] == "#" then
					 	@leavearray[target] = 0 if @leavearray[target] == nil
					 	@voterarray[target] = [] if @voterarray[target] == nil
					 	unvalidvoter = false
					 	for voter in @voterarray[target]
					 		if user == voter then
					 			unvalidvoter = true
					 		end
					 	end
					 	if unvalidvoter == false then
					 		@leavearray[target] = @leavearray[target] + 1
					 		if @leavearray[target] >= 6 then
					 			privmsg(target,"Six votes! I'm out")
					 			send("PART #{target}")
					 			@leavearray[target] = 0
					 			@voterarray[target] = []
					 		else
					 			privmsg(target,"There are now #{@leavearray[target]} out of 6 votes asking me to leave.")
					 			@voterarray[target].push user
					 		end
					 	else
					 		privmsg(target,"You have already voted.")
					 	end
					 else
					 	privmsg(target,"What the cruds are you trying to do?")
					 end
				when "live"
					if target[0..0] == "#" then
						@leavearray[target] = 0 if @leavearray[target] == nil
						@voterarray[target] = [] if @voterarray == nil
						validvoter = false
						for voter in @voterarray[target]
							if voter == user then
								validvoter = true
							end
						end
						if validvoter then
							@leavearray[target] -= 1
							@voterarray[target].delete(user)
							privmsg(target,"Vote removed. #{@leavearray[target]} votes remaining.")
						else
							privmsg(target,"You haven't voted!")
						end
					else
						privmsg(target,"What the cruds are you trying to do?")
					end
				when "die"
					if user == "NieXS" then
						disconnect()
					else
						privmsg(target,"Sorry Dave, I can't let you do that.")
					end
				when "thetime"
					privmsg(target,"The correct, Brazilian, time is: #{Time.now}")
				when "macro"
					if params =~ /(.+?)=(.+?)/ or params =~ /(.+?)=$/ then
						add_macro(target,params.split("=")[0],params.sub(params.split("=")[0]+"=",""))
					else
						privmsg(target,"Incorrect usage. RTFM.")
					end
				when "macrocheck"
					macrocheck(params,target)
				when "shutup"
					case @macros_enabled
						when true
							@macros_enabled = false
							privmsg(target,"Macros were disabled.")
						when false
							@macros_enabled = true
							privmsg(target,"Macros were re-enabled.")
					end
				when "wiki"
					if params != nil then
						params = params.sub("~wiki ","")
						privmsg(target,"Wikiing, hold on...")
						find_wiki(target,params,user)
					else
						privmsg(target,"Getting a random, hold on...")
						find_wiki(target,"Special:Random",user)
					end
				when "dieroll"
					dieroll(target,params)
				when "echo"
					if params != nil then params = params.sub("#{@command_identifier}echo ","").strip
						privmsg(target,params)
					else
						privmsg(target,"Echo what?")
					end
				when "linecount"
					self_file = File.open("/home/eduardo/marcobot/marcobot")
					test = self_file.readlines
					privmsg(target,"#{test.count} lines by now.")
				when "faidio"
					faidio(target)
				when "reloadmacros"
					@macrofile = File.open("#{@basepath}macros","r")
					@yamlmacros = YAML::load(@macrofile)
					@macrofile.rewind
					@macros = @macrofile.readlines
				when "eval"
					if user != "NieXS" then
						privmsg(target,"Don't")
					else
						eval(params.sub("#{@command_identifier}eval ","")+" > /tmp/eval.out")
						privmsg(target,File.readlines("/tmp/eval.out").join("\n").gsub("\n","\\n"))
					end
			end
		end
	end
	def dieroll(target,params)
		if params != nil then
			params.sub!("~dieroll ","")
			if params.strip =~ /^[0-9]+d[0-9]+$/ then
				dice_number = params.strip.split("d")[0].to_i
				side_number = params.strip.split("d")[1].sub("\n","").to_i
				# Throwing the dice
				i = 0
				sum = 0
				resultarray = []
				if dice_number <= 10 and side_number <= 20000 then
				while i < dice_number
					i += 1
					result = rand(side_number-1) +1
					sum += result
					resultarray.push result
				end
				end
				if sum == 0 or side_number <3 then
					privmsg(target,"You fail at making plausible dice.")
				else
					privmsg(target,resultarray.join(", ")+". Total: "+sum.to_s)
				end
			else
				privmsg(target,"Usage: (one)d(two), one is the number of dice, and two is the number of sides.")	end
		end
	end
end
# Go! Go! Go!
configfile = YAML::load(File.open("/home/eduardo/.marcobot/marcobotrc"))
irc = IRCBot.new(configfile["server"],configfile['port'],configfile['nickname'],configfile['channels'],configfile['nickserv_password'],configfile['basepath'])
begin
	irc.connect()
rescue Exception => detail
	puts "Fail'd to connect :("
	puts detail.message()
	puts detail.backtrace().join("\n")
	puts "Waiting..."
	puts "5..."
	sleep 1
	puts "4..."
	sleep 1
	puts "3..."
	sleep 1
	puts "2..."
	sleep 1
	puts "1..."
	sleep 1
	retry
end
begin
	irc.main_loop()
rescue Interrupt
	irc.privmsg("#faid3.0","Going down!")
rescue Exception => detail
	puts detail.message()
	puts "Backtrace:"
	for i in detail.backtrace()
		puts i 
	end
	irc.privmsg("#faid3.0","Oh dear, an exception: #{detail.message()}")
	sleep 1
	retry
rescue exit
end
