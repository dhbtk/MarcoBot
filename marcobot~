#!/usr/bin/env ruby
# MarcoBot: THE REWRITE; Version 2.0
# Firstly, the basics. Commands will come later. <-- are already coming (TWSS)
# Already supports:
# fucktons of things
#require 'rubygems'
require "socket"
require "yaml"
require "net/http"
require "rexml/document"
#require "hpricot"
class IRCBot
	# initialize: get these nasty vars and make them globals.
	def initialize(server,port,nick,autojoin_channels,ns_password,basepath)
		@server = server
		@port = port
		@nick = nick
		@channel = autojoin_channels.downcase.split(",")
		puts @channel
		@ns_password = ns_password
		@basepath = "/home/marcobot/"
		@command_identifier = "~"
		@leavearray = Hash.new
		@logarray = Hash.new
		@voterarray = Hash.new
		@macros_enabled = true
		@macrofile = nil
		@timeout = Time.new
		@macrotime = Hash.new
		@macrofile = File.open("#{@basepath}macros","r")
		@yamlmacros = YAML::load(@macrofile)
		@macrofile.rewind
		@macros = @macrofile.readlines
		
#		@blocking = false
	end
	# sends stuff through the socket
	def send(message)
#		puts "[#{Time.new.hour}:#{Time.new.min}:#{Time.new.sec}] --> #{message}"
		@irc.send "#{message}\n",0
		rawlog("--> #{message}")
	end
	# Connects to IRC
	def connect()
		@irc = TCPSocket.open(@server,@port)
		send("USER MarcoBot foo bar :NieXS' MacroBot, Version 2.0")
		send("NICK #{@nick}")
		@connected = true;
	end
	def disconnect()
		send("QUIT Farewell")
		@connected = false;
	end
	# Handles the input, passing it to the appropriate functions
	def handle_server_input(s)
		s = s.strip.chomp
		s_spaces = s.sub(":","").split
		s_colons = s.split(":")
		message = s_colons.join(":").sub(s_colons[1],"").sub("::","")
		if s_spaces[0] == "PING" then
			send "PONG "+s_spaces[1].sub(":","")
		elsif s_spaces[1] == "PRIVMSG" then
			user = s_spaces[0].sub(":","").split("!")[0]
			target = s_spaces[2]
			message = s_colons.join(":").sub(s_colons[1],"").sub("::","")
			handle_message(user,target,message)
		elsif s_spaces[1] == "INVITE" then
			handle_invite(s_spaces[3])
		elsif s_spaces[1] == "TOPIC" then
			handle_topic(s_spaces[0],s_spaces[2],s_colons.join(":").sub(s_colons[1],"").sub("::",""))
		elsif s_spaces[1] == "KICK" then
			handle_kick(s_spaces[0],s_spaces[2],s_spaces[3],s_spaces[4])
		elsif s == ":#{@nick} MODE #{@nick} :+wx" then
			startup_routine()
		elsif s_spaces[1] == "MODE" then
			if s_spaces[4] != nil then
				log(s_spaces[2],s_spaces[0],"#{s_spaces[3]} #{s_spaces[4]}","usermode")
			else
				log(s_spaces[2],s_spaces[0],s_spaces[3],"chanmode")
			end
		elsif s_spaces[1] == "PART" then
			log(s_spaces[2],s_spaces[0],message,"part")
			if s_spaces[0].split("!")[0] == @nick then
				@channel.delete(s_spaces[2].downcase)
			end
		elsif s_spaces[1] == "JOIN" then
			log(s_spaces[2],s_spaces[0],"","join")
			if s_spaces[0].split("!")[0] == @nick then
				@channel.push(s_spaces[2].sub(":","").downcase)
				privmsg(s_spaces[2].sub(":",""),"Hello people!")
			end
		elsif s_spaces[1] == "QUIT" then
			for channel in @channel
				log(channel,s_spaces[2],message,"quit")
			end
		elsif s_spaces[1] == "NICK" then
			if s_spaces[0].split("!")[0] == @nick then
				newnick = s_spaces[2].sub(":","").strip
				@nick = newnick
			end
			for channel in @channel
				log(channel,s_spaces[0],newnick,"nick")
			end
			
		end
		if s_spaces[0] = @server then
			log("Network",@server,s.strip,"network")
		end
	end
	# Looping and looping and looping again...
	def main_loop()
		while true and @connected
			ready = select([@irc],nil,nil,nil)
			next if !ready
			for s in ready[0]
				return if @irc.eof
				s = @irc.gets
				rawlog(s)
				handle_server_input(s)		
			end			
		end
	end
	def rawlog(s)
#		puts "#{timestamp(Time.new)} #{s}" 
		@rawlogfile = File.open("/var/log/marcobot/rawlog","a+")
		@rawlogfile.puts("#{timestamp(Time.new)}> #{s}")
		@rawlogfile.close()
	end
	def timestamp(time) # Pretty timestamps!
		hour = (time.hour<10 ? "0"+time.hour.to_s : time.hour)
		minute = (time.min<10 ? "0"+time.min.to_s : time.min)
		second = (time.sec<10 ? "0"+time.min.to_s : time.sec)
		thetime = "[#{hour}:#{minute}:#{second}]"
		return thetime
	end
	def handle_message(user,target,message)
		#Timplement macros so I can uncomment that line <-- bindun
		if target[0..0] == "#" then
			# Stuff that is happening in a chan; commented for testing
			check_for_macro(message,target,user) if @macros_enabled
			check_for_command(message,target,user)
			if message.sub("ACTION ","") == message then
				log(target,user,message,"privmsg")
			else
				log(target,user,message,"emote")
				if message.start_with?("ACTION rolls ") then
					dieroll(target,message.sub("ACTION rolls ","").sub("",""))
				end
			end
		else
			# Stuff in a PM.
			check_for_command(message,user,user)
			check_for_admin_command(message,user)
			if message.sub("ACTION ","") == message then
				log(user,user,message,"privmsg")
			else
				log(user,user,message,"emote")
			end
		end
	end
	def handle_invite(channel)
		#TODO: call for logs
#		if invited == @nick then
			send("JOIN #{channel}")
			privmsg(channel,"Hello #{channel}!")
#		end
#		log(channel,user,invited,"invite")
	end
	def handle_topic(user,channel,newtopic)
		#TODO
		log(channel,user,newtopic,"topic")

	end
	def handle_kick(kicker,kicked,channel,cause)
		#TODO: Call for logging
		if kicked == @nick then
			send "JOIN #{channel}"
			emote(channel,"kicks #{kicker} in the face")
		end
		log(channel,kicker,"#{kicked}\n#{cause}","kick")
	end
	def startup_routine()
		
		send("MODE #{@nick} +TB")
		for channel in @channel
			send("JOIN #{channel}")
		end
#		privmsg(@channel,"Hello everyone!")
		privmsg("NickServ","IDENTIFY #{@ns_password}")
	end
	# The needed: PRIVMSG
	def privmsg(target,message)
		send("PRIVMSG #{target} :#{message}")
		log(target,@nick,message,"privmsg")
	end
	# Because everyone loves /me
	def emote(target,message)
		privmsg(target,"ACTION #{message}")
		log(target,@nick,"ACTION #{message}","emote")
	end
	# Logging, because my mind said so
	def log(target,user,message,command)
		filepath = "/var/log/marcobot/logs/#{target.strip}-#{Time.new.day}-#{Time.new.month}-#{Time.new.year}".downcase
		if File.exists?(filepath) then
			@logarray[filepath] = File.open(filepath,"a")
		else
			@logarray[filepath] = File.new(filepath,"a")
		end
		
		case command
			when "privmsg"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} <#{user}> #{message.gsub("\n","")}"
			when "emote"
				time = Time.new
				message = message.sub("ACTION ","")
				message = message.gsub("","")
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} #{message.gsub("\n","")}"
			when "invite"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has invited #{message} into #{target}."
			when "topic"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has changed the topic to: #{message}"
			when "part"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user.split("!")[0]} (#{user}) has left #{target} (#{message})"
			when "join"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user.split("!")[0]} (#{user}) has joined #{target}"
			when "chanmode"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has changed the channel mode: #{message}"
			when "usermode"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has changed #{message.split(" ")[1]}'s mode: #{message.split(" ")[0]}"
			when "quit"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user.split("!")[0] unless user.class == NilClass} (#{user}) has left IRC: #{message}"
			when "kick"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} has kicked #{message.split("\n")[0]} from #{target} (#{message.split("\n")[1]})"
			when "network"
				time = Time.new
				@logarray[filepath].puts "#{timestamp(Time.new)} #{message}"
			when "nick"
				@logarray[filepath].puts "#{timestamp(Time.new)} ***#{user} is now known as #{message}."
				
		end
		@logarray[filepath].close()
	end
	#
	#|------------------------------|
	#|HUMUNGUOUS COMMANDS LAY BEYOND|
	#|------------------------------|
	#
	# Checks for ADMIN commands in messages. Format: ADMIN password ~command params
	def check_for_admin_command(message,user)
#		if message =~ /^ADMIN\s#{@command_identifier}(.+?)\s(.+?)\s(.+?)$/i or message =~ /^ADMIN\s#{@command_identifier}(.+?)\s(.+?)$/i then #TO#DO: remove regexes, do it like the normal command parser
#			params = $3
		if message[0..4] == "ADMIN" then
			message_split = message.split # By spaces, the default
			command = message_split[2].sub(@command_identifier,"")
			password = message_split[1]
			# Params are slightly more complicated. We need to set message_split[0,1,2] to nil first, and then join the message via spaces, and then strip the first three spaces. IF there is a param.
			if message_split[3] != nil then
				message_split[0] = nil
				message_split[1] = nil
				message_split[2] = nil
				params = message_split.join(" ")
				params = params.sub("   ","")
			end
			# It is a command. Let's see...
			if password == "854600" then
				case command
					when "die"
						# OH MY GOD THE NESTING
						disconnect()
					when "raw"
						send(params)
#					when "command" # Commented for not working
#						if params =~ /\s/ then
#							privmsg(user,"Don't.")
#						else
#							@command_identifier = params
#							privmsg(user,"The command identifier is now #{params}")
#						end
#					else
#						privmsg(user,"Unknown command, man.")
#				end
					when "help"
						privmsg(user,"ADMIN commands: die, raw, help, join, part.")
					when "join"
						send("JOIN #{params}")
					when "part"
						@leavearray[params.gsub(" ","")] = 0
						send("PART #{params}")
					when "nick"
						send("NICK #{params.strip}")
				end
			else
				privmsg(user,"Wrong password.")
			end
		end
	end
	def check_for_command(message,target,user)
#		if message =~ /^#{@command_identifer}(.+?)\s(.+?)$/i or message =~ /^#{@command_identifier}(.+?)$/i then
#			params = $2
		if message[0..@command_identifier.length-1] == @command_identifier then #TODO: unhardcode this
			message_split = message.split
			command = message_split[0] if message_split[1] != nil
			command = message if message_split[1] == nil
			command = command.sub(@command_identifier,"")	
			command = command.sub(" ","")
			if message_split[1] != nil then
				message_split[0] == ""
				params = message_split.join(" ")
#				params = params.sub(" ","")
			end
			case command
				when "help"
					privmsg(user,"Commands:")
					privmsg(user,"~help     : Shows this help.")
					privmsg(user,"~coinflip : Flips a coin [citation needed] and shows the outcome.")
					privmsg(user,"~8ball    : Ask a question to the mighty 8-ball. \"Should I?\" questions are preferred.")
					privmsg(user,"~leave    : Adds a vote for me to leave. Six votes = leave channel.")
					privmsg(user,"~live     : Unvotes.")
					privmsg(user,"~thetime  : Prints the Brazilian time.")
					privmsg(user,"~shutup   : Toggles macros.")
					privmsg(user,"~macro    : Sets macros. They must have more than five characters. Setting them to a space removes them. Usage: ~macro input phrase=output phrase")
					privmsg(user,"~wiki     : Usage: ~wiki Article. Case-sensitive. Buggy as hell, use at your own risk.")
					privmsg(user,"~dieroll  : Usage: ~dieroll (dice)d(sides). Both must be natural numbers, and larger than two for the sides.")
					privmsg(user,"~echo     : echo echo cho cho o o")
					privmsg(user,"~linecount: Number of lines in the source code.")
					privmsg(user,"~faidio   : Shows FaiDio streams.")
				when "coinflip"
					i = rand(2)
					case i
						when 0
							privmsg(target,"Heads.")
						when 1
							privmsg(target,"Tails.")
#						when 2
#							privmsg(target,"The coin landed on its edge. Talk about the odds.")
					end
				when "8ball"
					i = rand(6)
					case i 
						when 0
							privmsg(target,"Of course.")
						when 1
							privmsg(target,"Mmm, perhaps.")
						when 2
							privmsg(target,"You shouldn't.")
						when 3
							privmsg(target,"Not really.")
						when 4
							privmsg(target,"Don't or you will suffer.")
						when 5
							privmsg(target,"You can't know for sure.")
					end
				when "leave"
					 if target[0..0] == "#" then
					 	@leavearray[target] = 0 if @leavearray[target] == nil
					 	@voterarray[target] = [] if @voterarray[target] == nil
					 	unvalidvoter = false
					 	for voter in @voterarray[target]
					 		if user == voter then
					 			unvalidvoter = true
					 		end
					 	end
					 	if unvalidvoter == false then
					 		@leavearray[target] = @leavearray[target] + 1
					 		if @leavearray[target] >= 6 then
					 			privmsg(target,"Six votes! I'm out")
					 			send("PART #{target}")
					 			@leavearray[target] = 0
					 			@voterarray[target] = []
					 		else
					 			privmsg(target,"There are now #{@leavearray[target]} out of 6 votes asking me to leave.")
					 			@voterarray[target].push user
					 		end
					 	else
					 		privmsg(target,"You have already voted.")
					 	end
					 else
					 	privmsg(target,"What the cruds are you trying to do?")
					 end
				when "live"
					if target[0..0] == "#" then
						@leavearray[target] = 0 if @leavearray[target] == nil
						@voterarray[target] = [] if @voterarray == nil
						validvoter = false
						for voter in @voterarray[target]
							if voter == user then
								validvoter = true
							end
						end
						if validvoter then
							@leavearray[target] -= 1
							@voterarray[target].delete(user)
							privmsg(target,"Vote removed. #{@leavearray[target]} votes remaining.")
						else
							privmsg(target,"You haven't voted!")
						end
					else
						privmsg(target,"What the cruds are you trying to do?")
					end
				when "die"
					if user == "NieXS" then
#						send("QUIT Farewell")
#						exit()
						disconnect()
					else
						privmsg(target,"Sorry Dave, I can't let you do that.")
					end
				when "thetime"
					privmsg(target,"The correct, Brazilian, time is: #{Time.now}")
				when "macro"
					if params =~ /(.+?)=(.+?)/ or params =~ /(.+?)=$/ then
						add_macro(target,params.split("=")[0],params.sub(params.split("=")[0]+"=",""))
					else
						privmsg(target,"Incorrect usage. RTFM.")
					end
				when "macrocheck"
					macrocheck(params,target)
				when "shutup"
					case @macros_enabled
						when true
							@macros_enabled = false
							privmsg(target,"Macros were disabled.")
						when false
							@macros_enabled = true
							privmsg(target,"Macros were re-enabled.")
#					@macros = true; privmsg(target,"Macros are re-enabled") if @macros == false
#					@macros = false; privmsg(target,"Macros are disabled.") if @macros == true
					end
				when "wiki"
#					privmsg(target,"Wiki is really, really broken at the moment.")
					if params != nil then
						params = params.sub("~wiki ","")
						privmsg(target,"Wikiing, hold on...")
						find_wiki(target,params,user)
					else
						privmsg(target,"Getting a random, hold on...")
						find_wiki(target,"Special:Random",user)
					end
				when "dieroll"
					dieroll(target,params)
				when "echo"
					if params != nil then params = params.sub("#{@command_identifier}echo ","").strip
						privmsg(target,params)
					else
						privmsg(target,"Echo what?")
					end
				when "tvtropes"
#					privmsg(target,"Net::HTTP is acting up")
					if params != nil then params = params.sub("#{@command_identifier}echo ","").strip
						tvtropes(target,params)
					else
						privmsg(target,"No cookie for thou")
					end
				when "linecount"
					self_file = File.open("/home/marcobot/marcobot")
					test = self_file.readlines
					privmsg(target,"#{test.count} lines by now.")
				when "faidio"
					faidio(target)
					
				when "reloadmacros"
					@macrofile = File.open("#{@basepath}macros","r")
					@yamlmacros = YAML::load(@macrofile)
					@macrofile.rewind
					@macros = @macrofile.readlines
				when "eval"
					if user != "NieXS" then
						privmsg(target,"Don't")
					else
						privmsg(target,eval(params.sub("#{@command_identifier}eval ","")))
					end
			end
		end
	end
	def macrologic(message) # Outputs an array[trigger,macro,time_since_last_activation]
		macros = []
		triggers = []
		outputarray = []
		for macro in @macros
			macro_split = macro.split(": ")
			if message.downcase.include?(macro_split[0].downcase) and macro_split[0] != " " then
				triggers.push macro_split[0]
			end
		end
		if !triggers.empty? then
			triggers.sort! { |x,y| y.length <=> x.length }
			macro = @yamlmacros[triggers[0]]
			if @macrotime[triggers[0]] != nil then
				timeout = (Time.new - @macrotime[triggers[0]]).to_i
			else
				timeout = 999 # Obnoxiously large number
				@macrotime[triggers[0]] = 999
			end
			return [triggers[0],macro,timeout]
		else
			return nil
		end
	end
	def check_for_macro(message,target,user)
		macroarray = macrologic(message)
		if macroarray.class == Array then
			if macroarray[2] >= 300 then
				puts "Acceptable macro found!"
				output = macroarray[1].chomp
				output.gsub!("$nick",user)
				output.gsub!("$NICK",user.upcase)
				if output.start_with?("/me") then
					output.sub!("/me ","")
					emote(target,output)
				else
					privmsg(target,output)
				end
				@macrotime[macroarray[0]] = Time.new
			end
		end
	end
	def macrocheck(message,target)
		message.sub!("#{@command_identifier}macrocheck ","") # Ugly hack
		macroarray = macrologic(message)
		if macroarray.class == Array then
			if macroarray[2] >= 300 then
				privmsg(target,"The phrase \"#{message}\" triggers the macro \"#{macroarray[1].chomp}\".")
			else
				timeout = (((Time.new + 300).to_i - (Time.new - (Time.new - @macrotime[macroarray[0]])).to_i) - 600)*(-1) # I DON'T EVEN UNDERSTAND THIS ANYMORE
				privmsg(target,"The phrase \"#{message}\" will trigger the macro \"#{macroarray[1].chomp}\" in #{timeout.to_i} seconds.")
			end
		else
			privmsg(target,"The phrase \"#{message}\" doesn't trigger any macro.")
		end
	end
	def add_macro(channel,trigger,macro)
		trigger = trigger.sub("~macro ","")
		if macro != nil then macro.chomp!; end
		puts "DEBUG: channel: #{channel}, trigger: #{trigger}, macro: #{macro}"
		@macrofile = YAML::load(File.open("#{@basepath}macros"))
		if trigger.gsub(" ","").length >4 then
			if macro == nil then
				@macrofile.delete trigger.downcase
				privmsg(channel,"Macro removed.")
			else
				@macrofile[trigger.downcase] = macro
				privmsg(channel,"Macro added.")
			end
		else
			privmsg(channel,"Five chars or more, please.")
		end
		File.open("#{@basepath}macros","w") do |f|
			f << @macrofile.to_yaml
		end
		@macrofile = File.open("#{@basepath}macros","r")
		@yamlmacros = YAML::load(@macrofile)
		@macrofile.rewind
		@macros = @macrofile.readlines
	end
	def find_wiki(target,article,user)
		# Threading
		Thread.new do
		# cocks cocks cocks
		puts article
#		article[0..0] = article[0..0].upcase
		wiki = Net::HTTP.new("en.wikipedia.org",80)
		wiki.read_timeout= 10
		article[0..0] = article[0..0].upcase
		article = article.gsub(" ","_")
		reply = wiki.get("/wiki/#{article}",nil)
		puts reply.message
		if reply.message == "Moved Temporarily" then
			article = reply.header["location"].sub("http://en.wikipedia.org","")
#			reply = wiki.get(article,nil)
			reply = wiki.get("/wiki/#{article}",nil)
			privmsg(target,"Article: #{2.chr}#{article.sub("/wiki/","").gsub("_"," ")}#{2.chr}")
		end
		puts reply.message
		if reply.message != "OK" then
			privmsg(target,"No Such Article, Try Again")
		else
			outgoing = reply.body.scan(/\<\p\>(.+?)\<\/p\>$/i).uniq[0][0]
#			outgoing = outgoing.gsub("<b>","").gsub("</b>","")
#			outgoing = outgoing.gsub("<i>","").gsub("</i>","")
#			outgoing = outgoing.gsub(/\s(.+?)=\"(.+?)\"/,"").gsub(/(>+)/,">") #Doesn't work
#			puts outgoing
			outgoing = outgoing.gsub("<b>",2.chr.to_s).gsub("</b>",2.chr.to_s)
			outgoing = outgoing.gsub("<i>",0x1F.chr.to_s).gsub("</i>",0x1F.chr.to_s)
#			outgoing = outgoing.gsub("<a>",0x1F.chr.to_s).gsub("</a>",0x1F.chr.to_s) # Doesn't work
			outgoing = outgoing.gsub(/<(\/|\s)*[^(b)][^>]*>/,'')
			if outgoing[-1..-1] == ":" then
				listofthings = reply.body.scan(/\<\li\>(.+?)\<\/li\>$/i)
				listofthings = listofthings.join(", ")
#				listofthings = listofthings.gsub("<b>","").gsub("</b>","")
#				outgoing = outgoing.gsub("<i>","").gsub("</i>","")
				listofthings = listofthings.gsub("<b>",2.chr.to_s).gsub("</b>",2.chr.to_s)
				listofthings = listofthings.gsub("<i>",0x1F.chr.to_s).gsub("</i>",0x1F.chr.to_s)
				listofthings = listofthings.gsub(/<(\/|\s)*[^(b)][^>]*>/,'')
				outgoing = outgoing + " " + listofthings + "."
			elsif outgoing[0,12] == "Coordinates:"
				outgoing = reply.body.scan(/\<\p\>(.+?)\<\/p\>$/i).uniq[1][0] # Doesn't work. TODO: Make it work
				outgoing = outgoing.gsub("<b>",2.chr.to_s).gsub("</b>",2.chr.to_s)
				outgoing = outgoing.gsub("<i>",0x1F.chr.to_s).gsub("</i>",0x1F.chr.to_s)
				outgoing = outgoing.gsub(/<(\/|\s)*[^(b)][^>]*>/,'')
			end
			if outgoing.length >400 then
#				privmsg(target,"P long, sending a PM.")
#				outgoing1 = outgoing[0..419]
#				outgoing2 = outgoing[420..outgoing.length-1]
#				if outgoing2[0,1] == " " then
#					outgoing2[0,1] = ""
#				end
#				privmsg(target,outgoing1)
#				privmsg(target,outgoing2)
				outgoing_array = outgoing.unpack("A400A400A400A400A400A400A400A400A400") # Not cool, not funny, not a good way to do things.
				for item in outgoing_array
					if item == "" then
						outgoing_array.delete(item)
#						puts 1 + "cocks" + nil # haha
					end
				end
				puts outgoing_array.count
#				if outgoing_array.count <= 2 then
#					target = target
#				else
#					privmsg(target,"Sending a PM for long.")
#					target = user
#				end
				for outgoing in outgoing_array
					
					privmsg(target,outgoing.strip.gsub("&#160;"," "))
					sleep 0.4
				end
			else
				privmsg(target,outgoing.strip.gsub("&#160;"," "))
			end
		end
	end
	end
	def faidio(target)
		# Threads!
		Thread.new do
		Net::HTTP.start("sajuuk.org",8001) do |http|
			req = Net::HTTP::Get.new("/admin/stats.xml")
			req.basic_auth("admin","854600")
			reply = http.request(req)
			$xmlfile = reply.body
		end
#		puts @xmlfile
		$xmlfile = REXML::Document.new $xmlfile
		@root = $xmlfile.root
#		xmlfile.elements.each("icestats/sources") { |sources| $sources_num = sources.text.to_i }
		if @root.elements["sources"].text.to_i >= 1 then
			privmsg(target,"Streams:")
			$xmlfile.elements.each("icestats/source") do |source|
				mountpoint = source.attributes["mount"]
				listeners_plus_peak = source.elements["listeners"].text+"/"+source.elements["listener_peak"].text
				artist_title = source.elements["artist"].text+" - "+source.elements["title"].text
				name_description = source.elements["server_name"].text+" ("+source.elements['server_description'].text+")"
				if source.elements["listenurl"] != nil then
					listen_url = source.elements["listenurl"].text
				else
					listen_url = ""
				end
				samplerate = source.elements["audio_samplerate"].text
				if source.elements["ice-channels"] != nil then
					channels = (source.elements["ice-channels"].text.to_i>1 ? "Stereo" : "Mono")
				elsif source.elements["audio_channels"] != nil then
					channels = (source.elements["audio_channels"].text.to_i>1 ? "Stereo" : "Mono")
				else
					channels = "unknown"
				end
				genre = source.elements["genre"].text
				subtype = source.elements["subtype"].text
				output = name_description+" at "+listen_url+"; Genre is "+genre+"; "+listeners_plus_peak+" listeners. Streaming in "+channels+" at "+samplerate+" Hz using "+subtype+". Now playing: "+artist_title
				privmsg(target,output)
			end
				
		else
			privmsg(target,"No one is streaming.")
		end
	end
	end
	def dieroll(target,params)
		if params != nil then
			params.sub!("~dieroll ","")
			if params.strip =~ /^[0-9]+d[0-9]+$/ then
				dice_number = params.strip.split("d")[0].to_i
				side_number = params.strip.split("d")[1].sub("\n","").to_i
				# Throwing the dice
				i = 0
				sum = 0
				resultarray = []
				if dice_number <= 10 and side_number <= 20000 then
				while i < dice_number
					i += 1
					result = rand(side_number-1) +1
					sum += result
					resultarray.push result
				end
				end
				if sum == 0 or side_number <3 then
					privmsg(target,"You fail at making plausible dice.")
				else
					privmsg(target,resultarray.join(", ")+". Total: "+sum.to_s)
				end
			else
				privmsg(target,"Usage: (one)d(two), one is the number of dice, and two is the number of sides.")	end
		end
	end
end
# Go! Go! Go!
configfile = YAML::load(File.open("/home/eduardo/.marcobot/marcobotrc"))
irc = IRCBot.new(configfile["server"],configfile['port'],configfile['nickname'],configfile['channels'],configfile['nickserv_password'],configfile['basepath'])
begin
	irc.connect()
rescue Exception => detail
	puts "Fail'd to connect :("
	puts detail.message()
	puts detail.backtrace().join("\n")
	puts "Waiting..."
	puts "5..."
	sleep 1
	puts "4..."
	sleep 1
	puts "3..."
	sleep 1
	puts "2..."
	sleep 1
	puts "1..."
	sleep 1
	retry
end
begin
	irc.main_loop()
rescue Interrupt
	irc.privmsg("#faid3.0","Going down!")
rescue Exception => detail
	puts "HALP! Forward this to NieXS:"
	puts detail.message()
	puts "Backtrace:"
	for i in detail.backtrace()
		puts i 
	end
	irc.privmsg("#faid3.0","OH SHIT EXCEPTION")
	sleep 1
	retry
rescue exit
end
